<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Padel Replay – Last X Seconds</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #000;
      color: #fff;
    }

    /* Page layout: scrollable, video at top, controls under it */
    #videoContainer {
      position: relative;
      width: 100%;
      height: 90vh;               /* use top ~90% of screen */
      background: #000;
    }

    video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    #controls {
      position: sticky;
      bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px 12px calc(18px + env(safe-area-inset-bottom));
      background: rgba(0, 0, 0, 0.9);
      gap: 8px;
    }

    #status {
      font-size: 14px;
      opacity: 0.8;
      text-align: center;
    }

    #timer {
      font-size: 14px;
      opacity: 0.8;
      text-align: center;
    }

    #settingsRow,
    #cutoffRow {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-size: 14px;
      flex-wrap: wrap;
    }

    input[type="number"] {
      width: 70px;
      padding: 4px 6px;
      border-radius: 999px;
      border: none;
      text-align: center;
      font-size: 14px;
    }

    #buttons {
      display: flex;
      gap: 12px;
      width: 100%;
      justify-content: center;
    }

    button {
      flex: 1;
      max-width: 180px;
      padding: 10px 14px;
      font-size: 16px;
      border-radius: 999px;
      border: none;
      font-weight: 600;
      cursor: pointer;
    }

    #startBtn {
      background: #16a34a;
      color: #fff;
    }

    #saveBtn {
      background: #dc2626;
      color: #fff;
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
    }

    /* Saving overlay */
    #savingOverlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 10;
      text-align: center;
      padding: 20px;
    }

    #savingText {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 6px;
    }

    #savingSub {
      font-size: 14px;
      opacity: 0.85;
    }

    .spinner {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-top-color: #fff;
      animation: spin 1s linear infinite;
      margin-bottom: 10px;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>
<body>
  <div id="videoContainer">
    <video id="preview" playsinline autoplay muted></video>

    <!-- Saving overlay -->
    <div id="savingOverlay">
      <div class="spinner"></div>
      <div id="savingText">Saving highlight…</div>
      <div id="savingSub">Converting to iPhone video…</div>
    </div>
  </div>

  <div id="controls">
    <div id="status">Set times and tap “Start Camera”.</div>
    <div id="timer">Streaming: 00:00</div>

    <div id="settingsRow">
      <span>Buffer:</span>
      <input id="bufferInput" type="number" min="5" max="120" step="5" value="30" />
      <span>seconds</span>
    </div>

    <div id="cutoffRow">
      <span>Cut off last:</span>
      <input id="cutoffInput" type="number" min="0" max="15" step="1" value="3" />
      <span>seconds</span>
    </div>

    <div id="buttons">
      <button id="startBtn">Start Camera</button>
      <button id="saveBtn" disabled>Save last Xs</button>
    </div>
  </div>

  <!-- FFmpeg WASM for in-browser conversion -->
  <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>
  <script>
    const preview = document.getElementById("preview");
    const startBtn = document.getElementById("startBtn");
    const saveBtn = document.getElementById("saveBtn");
    const statusEl = document.getElementById("status");
    const timerEl = document.getElementById("timer");
    const bufferInput = document.getElementById("bufferInput");
    const cutoffInput = document.getElementById("cutoffInput");
    const savingOverlay = document.getElementById("savingOverlay");

    let mediaStream = null;
    let mediaRecorder = null;
    let bufferChunks = [];
    let bufferSeconds = 30; // default buffer length
    let cutoffSeconds = 3;  // default cutoff
    const timesliceMs = 1000; // 1 second chunks
    let isSaving = false;

    let startTime = null;
    let timerIntervalId = null;

    // FFmpeg setup
    const { createFFmpeg, fetchFile } = FFmpeg;
    const ffmpeg = createFFmpeg({
	  log: false
    });
    let ffmpegLoaded = false;

    async function ensureFfmpegLoaded() {
      if (ffmpegLoaded) return;
      setStatus("Loading video encoder (first time only)…");
      await ffmpeg.load();
      ffmpegLoaded = true;
      setStatus(
        "Encoder loaded. Buffer: " +
          bufferSeconds +
          "s, cut off last " +
          cutoffSeconds +
          "s."
      );
    }

    function setStatus(text) {
      statusEl.textContent = text;
      console.log(text);
    }

    function formatTime(seconds) {
      const m = Math.floor(seconds / 60);
      const s = Math.floor(seconds % 60);
      return `${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
    }

    function startTimer() {
      startTime = Date.now();
      if (timerIntervalId) clearInterval(timerIntervalId);
      timerIntervalId = setInterval(() => {
        const elapsedSec = (Date.now() - startTime) / 1000;
        timerEl.textContent = "Streaming: " + formatTime(elapsedSec);
      }, 1000);
    }

    function stopTimer() {
      if (timerIntervalId) {
        clearInterval(timerIntervalId);
        timerIntervalId = null;
      }
    }

    function updateBufferSecondsFromInput() {
      const raw = parseInt(bufferInput.value, 10);
      if (isNaN(raw)) {
        bufferInput.value = bufferSeconds;
        return;
      }
      bufferSeconds = Math.max(5, Math.min(120, raw));
      bufferInput.value = bufferSeconds;
      if (cutoffSeconds >= bufferSeconds) {
        cutoffSeconds = Math.max(0, bufferSeconds - 1);
        cutoffInput.value = cutoffSeconds;
      }
      updateStatusReady();
    }

    function updateCutoffSecondsFromInput() {
      const raw = parseInt(cutoffInput.value, 10);
      if (isNaN(raw)) {
        cutoffInput.value = cutoffSeconds;
        return;
      }
      cutoffSeconds = Math.max(0, Math.min(15, raw));
      if (cutoffSeconds >= bufferSeconds) {
        cutoffSeconds = Math.max(0, bufferSeconds - 1);
      }
      cutoffInput.value = cutoffSeconds;
      updateStatusReady();
    }

    function updateStatusReady() {
      setStatus(
        "Ready. Buffer: " +
          bufferSeconds +
          "s, cut off last " +
          cutoffSeconds +
          "s. Tap “Start Camera” to begin."
      );
      document.getElementById("savingSub").textContent =
        "Converting to iPhone video… (ends ~" + cutoffSeconds + "s before press)";
    }

    bufferInput.addEventListener("change", updateBufferSecondsFromInput);
    bufferInput.addEventListener("blur", updateBufferSecondsFromInput);
    cutoffInput.addEventListener("change", updateCutoffSecondsFromInput);
    cutoffInput.addEventListener("blur", updateCutoffSecondsFromInput);

    async function startCamera() {
      if (mediaStream) return; // already running

      updateBufferSecondsFromInput();
      updateCutoffSecondsFromInput();

      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        setStatus(
          "This browser does not support camera access (getUserMedia missing)."
        );
        return;
      }

      try {
        const constraints = {
          video: {
            facingMode: { ideal: "environment" },
            width: { ideal: 1920 },
            height: { ideal: 1080 }
          },
          audio: true
        };

        mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
        preview.srcObject = mediaStream;

        startRecording();

        startBtn.disabled = true;
        saveBtn.disabled = false;
        setStatus(
          "Recording… buffer holds last " +
            bufferSeconds +
            "s. Clip will end ~" +
            cutoffSeconds +
            "s before you press Save."
        );
      } catch (err) {
        console.error(err);
        setStatus("Error accessing camera/mic: " + err.message);
      }
    }

    function startRecording() {
      if (!mediaStream) {
        setStatus("No media stream.");
        return;
      }

      // Let Safari pick its best recording format
      let options = {};
      if (typeof MediaRecorder.isTypeSupported === "function") {
        if (MediaRecorder.isTypeSupported("video/mp4")) {
          options.mimeType = "video/mp4";
        } else if (MediaRecorder.isTypeSupported("video/webm;codecs=vp9")) {
          options.mimeType = "video/webm;codecs=vp9";
        } else if (MediaRecorder.isTypeSupported("video/webm;codecs=vp8")) {
          options.mimeType = "video/webm;codecs=vp8";
        } else if (MediaRecorder.isTypeSupported("video/webm")) {
          options.mimeType = "video/webm";
        }
      }

      try {
        mediaRecorder = new MediaRecorder(mediaStream, options);
      } catch (err) {
        console.error(err);
        setStatus("MediaRecorder init failed: " + err.message);
        return;
      }

      bufferChunks = [];

      mediaRecorder.ondataavailable = (event) => {
        if (!event.data || event.data.size === 0) return;
        bufferChunks.push(event.data);

        const maxChunks = Math.ceil((bufferSeconds * 1000) / timesliceMs);
        if (bufferChunks.length > maxChunks) {
          bufferChunks.splice(0, bufferChunks.length - maxChunks);
        }
      };

      mediaRecorder.onstart = () => {
        startTimer();
        setStatus(
          "Recording… buffer: " +
            bufferSeconds +
            "s, cutting last " +
            cutoffSeconds +
            "s. Tap “Save last Xs” for highlight."
        );
      };

      mediaRecorder.onerror = (e) => {
        console.error("Recorder error", e);
        setStatus("Recorder error: " + (e.error?.name ?? "unknown"));
      };

      mediaRecorder.onstop = () => {
        stopTimer();
      };

      // 1s chunks
      mediaRecorder.start(timesliceMs);
    }

    function showSavingOverlay(show) {
      savingOverlay.style.display = show ? "flex" : "none";
    }

    async function saveLastSeconds() {
      if (isSaving) return;
      if (!mediaRecorder || bufferChunks.length === 0) {
        setStatus("Nothing in buffer yet. Wait a bit after starting.");
        return;
      }

      const cutoffChunks = Math.round((cutoffSeconds * 1000) / timesliceMs);
      if (bufferChunks.length <= cutoffChunks + 1) {
        setStatus(
          "Not enough history yet to cut " +
            cutoffSeconds +
            "s. Play a bit longer before saving."
        );
        return;
      }

      isSaving = true;
      saveBtn.disabled = true;
      saveBtn.textContent = "Saving…";
      showSavingOverlay(true);
      setStatus(
        "Preparing highlight of last " +
          bufferSeconds +
          "s (ending ~" +
          cutoffSeconds +
          "s before button press)… " +
          "(chunks: " +
          bufferChunks.length +
          ")"
      );

      try {
        // Build highlight blob in native recorder format first
        const effectiveChunks = bufferChunks.slice(
          0,
          bufferChunks.length - cutoffChunks
        );

        const sourceMimeType = mediaRecorder.mimeType || "video/webm";
        const highlightBlob = new Blob(effectiveChunks, { type: sourceMimeType });

        if (highlightBlob.size === 0) {
          setStatus(
            "Highlight blob is empty – your browser may not support this MediaRecorder setup."
          );
        } else {
          // Convert to real MP4 (H.264/AAC) via FFmpeg so iOS Files/Photos can open it
          await ensureFfmpegLoaded();
          setStatus(
            "Converting highlight to MP4 (this may take a few seconds)…"
          );
          document.getElementById("savingText").textContent = "Converting…";
          document.getElementById("savingSub").textContent =
            "Encoding to iPhone-compatible video…";

          // Write input file to FFmpeg FS
          ffmpeg.FS(
            "writeFile",
            "input",
            await fetchFile(highlightBlob)
          );

          // Highest quality: keep resolution, H.264 + AAC
          await ffmpeg.run(
            "-i", "input",
            "-c:v", "libx264",
            "-preset", "slow",
            "-crf", "20",
            "-pix_fmt", "yuv420p",
            "-c:a", "aac",
            "-b:a", "128k",
            "-movflags", "+faststart",
            "output.mp4"
          );

          const data = ffmpeg.FS("readFile", "output.mp4");
          const mp4Blob = new Blob([data.buffer], { type: "video/mp4" });

          // Clean FS for next run
          ffmpeg.FS("unlink", "input");
          ffmpeg.FS("unlink", "output.mp4");

          const url = URL.createObjectURL(mp4Blob);
          const a = document.createElement("a");
          a.style.display = "none";
          a.href = url;
          a.download = `padel-highlight-${bufferSeconds}s-cut${cutoffSeconds}s-${Date.now()}.mp4`;

          document.body.appendChild(a);
          a.click();

          setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          }, 4000);

          setStatus(
            "Highlight saved as MP4 (last " +
              bufferSeconds +
              "s, ending ~" +
              cutoffSeconds +
              "s before press). You should be able to open it from Files."
          );
        }
      } catch (err) {
        console.error(err);
        setStatus("Error while saving/converting highlight: " + err.message);
      } finally {
        setTimeout(() => {
          isSaving = false;
          saveBtn.disabled = false;
          saveBtn.textContent = "Save last Xs";
          document.getElementById("savingText").textContent = "Saving highlight…";
          document.getElementById("savingSub").textContent =
            "Converting to iPhone video…";
          showSavingOverlay(false);
        }, 3000);
      }
    }

    startBtn.addEventListener("click", startCamera);
    saveBtn.addEventListener("click", saveLastSeconds);

    // iOS sometimes needs a user gesture first
    document.body.addEventListener(
      "touchstart",
      () => {},
      { once: true }
    );

    // initial status
    updateStatusReady();
  </script>
</body>
</html>
